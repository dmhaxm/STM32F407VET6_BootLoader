上位机用的VS2022，.net.4.7.2，可以转到.net8独立发布，就是要做一些更改

下位机用的VSCode+Keil5.42.0，主要VSCode编写，Keil调试

初步实现了上下位机之间一次2K数据分包传输。




稍微记录一下这次学习经历，从一开始对Bootloader的不甚了解，到现在成功完成程序编写和初步调试，收货颇丰，下面来总结一下碰到的一些问题：

Q1:上位机程序可以跳转到APP程序，但APP程序中HAL_Delay函数无法使用。

Bootloader程序中把中断都禁用了，所以导致APP程序无法使用依靠中断的HAL_Delay函数，通过依靠软件延时逐步排查出问题。

Q2:编写好Bootloader后第一版后进行UART升级，发现和上位机一直通信超时。
一直在排查代码问题，突然发现好像是板子232通信有问题，使用最基础的串口发送和接收上下位机都无法实现通信，于是便再买了一块STM32F407VET6的开发板，等待的时间顺便简单学一下HAL库，并且把之前使用标准库写的Bootloader代码改成HAL库的。

Q3:VSCode和Keil都是UTF-8，但是使用Cubemx重新生成一下代码后就有部分注释会乱码

因为Cubemx是不支持自选编码格式的，所以我尝试过每次在Cubemxc重新生成一个代码后启动一个脚本，使其文件的编码格式全都改成UTF-8，但是尝试了几次后总会有各种问题，所以暂时先放弃。排查后发现主要是最后一个字会乱码，所以可以每次在中文注释最后多打一个空格，这样哪怕是乱码也是空格被乱码，没有任何影响。

Q4:串口通信调通后Bootloader上下位机之间的通信依旧超时。

发现是没有进行最基础程序升级判断，串口有数据也依旧跳转到APP程序，增加了升级状态追踪功能。

Q5:上位机程序使用Label来显示当前状态步骤，每次都会覆盖之前的记录很不利于调试。

将交互控件从Label改成了ListBox，并且新增了时间显示，这样就能显示之前每一步的记录，也利于调试。

Q6:上下位机能成功握手和确认文件信息，但一到bin文件数据传输部分就超时

逐步排查发现可能是单次传输的数据包太大，并且CPU进行FLASH的擦除和写入都需要时间，导致超时，因此将Bootloader的数据接收发送方式从轮询改成中断方式，测试后发现还是不行，因此再次改成DMA传输，这样DMA独立于CPU运行，即使CPU忙于Flash操作也能接收数据，然后一番测试后将模式再次改成DMA+空闲中断，这样测试后一部分数据能成功发送

Q7:发送数据好好的上位机报错通信超时

发现是Flash写入期间禁用了所有中断，导致DMA和UART空闲中断模式无法接受数据，解除禁用后就能正常传输了。

Q8:上位机显示固件升级完成后，下位机升级后的APP程序无法使用

我查了一下栈指针和复位向量的具体数值，发现都是正常的，也就是能正常跳转。
然后进行了控制变量法测试，我通过两种方式进行了程序下载，一种是通过我写的Bootloader程序进行下载bin文件，另一种是通过STM32 ST-LINK Utility下周bin文件，我每次都把芯片重新擦除控制变量，前者无法使用，后者APP程序正常。
因此我将它们对应操作后的bin文件导出进行比较，我专门写了一个bin文件比较的简单的exe程序，发现使用Bootloader写入Flash时数据被损坏了，导致 Bootloader能检测到"有效"应用程序 (因为数据格式看起来正确)并且能够正常跳转 (跳转逻辑正确)但应用程序不运行 (因为中断向量表和代码都损坏了)。
一番排查后发现是DMA接收缓冲区冲突，数据包处理完成后立即重新启动DMA接收，但Flash写入可能仍在进行中，可能导致数据缓冲区被覆盖。因此进行了数据缓冲区保护处理，创建了本地数据副本，避免DMA缓冲区覆盖问题，并且进行了写入性能优化，减少延时频率。

顺便提一嘴Keil能生成bin文件，只要在USER那里加上生成bin文件代码：fromelf --bin -o ".\bin_file\@L.bin" "#L"

Q9烧录后的程序能够正常使用，但是一旦烧录的程序大小变大，最后一个包就是无法接收完成，显示超时

我一开始尝试增加超时时间和再次优化写入性能，发现还是那个问题。经过一番排查后发现是发生了粘包现象，导致上位机只处理了第一个包，忽略了第二个包，而升级完成的信息是在第二个包里，进行了粘包优化后就好了。
